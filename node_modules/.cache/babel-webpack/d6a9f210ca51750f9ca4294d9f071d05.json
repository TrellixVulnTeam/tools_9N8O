{"ast":null,"code":"import _classCallCheck from \"/home/cynefin/Desktop/Angular Basics/blog/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/cynefin/Desktop/Angular Basics/blog/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _regeneratorRuntime from \"/home/cynefin/Desktop/Angular Basics/blog/node_modules/@babel/runtime/regenerator\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nvar logger = new Logger(version);\nimport { id } from \"./id\";\nvar padding = new Uint8Array(32);\npadding.fill(0);\nvar NegativeOne = BigNumber.from(-1);\nvar Zero = BigNumber.from(0);\nvar One = BigNumber.from(1);\nvar MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n\nfunction hexPadRight(value) {\n  var bytes = arrayify(value);\n  var padOffset = bytes.length % 32;\n\n  if (padOffset) {\n    return hexConcat([bytes, padding.slice(padOffset)]);\n  }\n\n  return hexlify(bytes);\n}\n\nvar hexTrue = hexZeroPad(One.toHexString(), 32);\nvar hexFalse = hexZeroPad(Zero.toHexString(), 32);\nvar domainFieldTypes = {\n  name: \"string\",\n  version: \"string\",\n  chainId: \"uint256\",\n  verifyingContract: \"address\",\n  salt: \"bytes32\"\n};\nvar domainFieldNames = [\"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"];\n\nfunction checkString(key) {\n  return function (value) {\n    if (typeof value !== \"string\") {\n      logger.throwArgumentError(\"invalid domain value for \".concat(JSON.stringify(key)), \"domain.\".concat(key), value);\n    }\n\n    return value;\n  };\n}\n\nvar domainChecks = {\n  name: checkString(\"name\"),\n  version: checkString(\"version\"),\n  chainId: function chainId(value) {\n    try {\n      return BigNumber.from(value).toString();\n    } catch (error) {}\n\n    return logger.throwArgumentError(\"invalid domain value for \\\"chainId\\\"\", \"domain.chainId\", value);\n  },\n  verifyingContract: function verifyingContract(value) {\n    try {\n      return getAddress(value).toLowerCase();\n    } catch (error) {}\n\n    return logger.throwArgumentError(\"invalid domain value \\\"verifyingContract\\\"\", \"domain.verifyingContract\", value);\n  },\n  salt: function salt(value) {\n    try {\n      var bytes = arrayify(value);\n\n      if (bytes.length !== 32) {\n        throw new Error(\"bad length\");\n      }\n\n      return hexlify(bytes);\n    } catch (error) {}\n\n    return logger.throwArgumentError(\"invalid domain value \\\"salt\\\"\", \"domain.salt\", value);\n  }\n};\n\nfunction getBaseEncoder(type) {\n  // intXX and uintXX\n  {\n    var match = type.match(/^(u?)int(\\d*)$/);\n\n    if (match) {\n      var signed = match[1] === \"\";\n      var width = parseInt(match[2] || \"256\");\n\n      if (width % 8 !== 0 || width > 256 || match[2] && match[2] !== String(width)) {\n        logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n      }\n\n      var boundsUpper = MaxUint256.mask(signed ? width - 1 : width);\n      var boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n      return function (value) {\n        var v = BigNumber.from(value);\n\n        if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n          logger.throwArgumentError(\"value out-of-bounds for \".concat(type), \"value\", value);\n        }\n\n        return hexZeroPad(v.toTwos(256).toHexString(), 32);\n      };\n    }\n  } // bytesXX\n\n  {\n    var _match = type.match(/^bytes(\\d+)$/);\n\n    if (_match) {\n      var _width = parseInt(_match[1]);\n\n      if (_width === 0 || _width > 32 || _match[1] !== String(_width)) {\n        logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n      }\n\n      return function (value) {\n        var bytes = arrayify(value);\n\n        if (bytes.length !== _width) {\n          logger.throwArgumentError(\"invalid length for \".concat(type), \"value\", value);\n        }\n\n        return hexPadRight(value);\n      };\n    }\n  }\n\n  switch (type) {\n    case \"address\":\n      return function (value) {\n        return hexZeroPad(getAddress(value), 32);\n      };\n\n    case \"bool\":\n      return function (value) {\n        return !value ? hexFalse : hexTrue;\n      };\n\n    case \"bytes\":\n      return function (value) {\n        return keccak256(value);\n      };\n\n    case \"string\":\n      return function (value) {\n        return id(value);\n      };\n  }\n\n  return null;\n}\n\nfunction encodeType(name, fields) {\n  return \"\".concat(name, \"(\").concat(fields.map(function (_ref) {\n    var name = _ref.name,\n        type = _ref.type;\n    return type + \" \" + name;\n  }).join(\",\"), \")\");\n}\n\nexport var TypedDataEncoder = /*#__PURE__*/function () {\n  function TypedDataEncoder(types) {\n    _classCallCheck(this, TypedDataEncoder);\n\n    defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n    defineReadOnly(this, \"_encoderCache\", {});\n    defineReadOnly(this, \"_types\", {}); // Link struct types to their direct child structs\n\n    var links = {}; // Link structs to structs which contain them as a child\n\n    var parents = {}; // Link all subtypes within a given struct\n\n    var subtypes = {};\n    Object.keys(types).forEach(function (type) {\n      links[type] = {};\n      parents[type] = [];\n      subtypes[type] = {};\n    });\n\n    var _loop = function _loop(name) {\n      var uniqueNames = {};\n      types[name].forEach(function (field) {\n        // Check each field has a unique name\n        if (uniqueNames[field.name]) {\n          logger.throwArgumentError(\"duplicate variable name \".concat(JSON.stringify(field.name), \" in \").concat(JSON.stringify(name)), \"types\", types);\n        }\n\n        uniqueNames[field.name] = true; // Get the base type (drop any array specifiers)\n\n        var baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n\n        if (baseType === name) {\n          logger.throwArgumentError(\"circular type reference to \".concat(JSON.stringify(baseType)), \"types\", types);\n        } // Is this a base encoding type?\n\n\n        var encoder = getBaseEncoder(baseType);\n\n        if (encoder) {\n          return;\n        }\n\n        if (!parents[baseType]) {\n          logger.throwArgumentError(\"unknown type \".concat(JSON.stringify(baseType)), \"types\", types);\n        } // Add linkage\n\n\n        parents[baseType].push(name);\n        links[name][baseType] = true;\n      });\n    };\n\n    for (var name in types) {\n      _loop(name);\n    } // Deduce the primary type\n\n\n    var primaryTypes = Object.keys(parents).filter(function (n) {\n      return parents[n].length === 0;\n    });\n\n    if (primaryTypes.length === 0) {\n      logger.throwArgumentError(\"missing primary type\", \"types\", types);\n    } else if (primaryTypes.length > 1) {\n      logger.throwArgumentError(\"ambiguous primary types or unused types: \".concat(primaryTypes.map(function (t) {\n        return JSON.stringify(t);\n      }).join(\", \")), \"types\", types);\n    }\n\n    defineReadOnly(this, \"primaryType\", primaryTypes[0]); // Check for circular type references\n\n    function checkCircular(type, found) {\n      if (found[type]) {\n        logger.throwArgumentError(\"circular type reference to \".concat(JSON.stringify(type)), \"types\", types);\n      }\n\n      found[type] = true;\n      Object.keys(links[type]).forEach(function (child) {\n        if (!parents[child]) {\n          return;\n        } // Recursively check children\n\n\n        checkCircular(child, found); // Mark all ancestors as having this decendant\n\n        Object.keys(found).forEach(function (subtype) {\n          subtypes[subtype][child] = true;\n        });\n      });\n      delete found[type];\n    }\n\n    checkCircular(this.primaryType, {}); // Compute each fully describe type\n\n    for (var _name in subtypes) {\n      var st = Object.keys(subtypes[_name]);\n      st.sort();\n      this._types[_name] = encodeType(_name, types[_name]) + st.map(function (t) {\n        return encodeType(t, types[t]);\n      }).join(\"\");\n    }\n  }\n\n  _createClass(TypedDataEncoder, [{\n    key: \"getEncoder\",\n    value: function getEncoder(type) {\n      var encoder = this._encoderCache[type];\n\n      if (!encoder) {\n        encoder = this._encoderCache[type] = this._getEncoder(type);\n      }\n\n      return encoder;\n    }\n  }, {\n    key: \"_getEncoder\",\n    value: function _getEncoder(type) {\n      var _this = this;\n\n      // Basic encoder type (address, bool, uint256, etc)\n      {\n        var encoder = getBaseEncoder(type);\n\n        if (encoder) {\n          return encoder;\n        }\n      } // Array\n\n      var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n      if (match) {\n        var subtype = match[1];\n        var subEncoder = this.getEncoder(subtype);\n        var length = parseInt(match[3]);\n        return function (value) {\n          if (length >= 0 && value.length !== length) {\n            logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n          }\n\n          var result = value.map(subEncoder);\n\n          if (_this._types[subtype]) {\n            result = result.map(keccak256);\n          }\n\n          return keccak256(hexConcat(result));\n        };\n      } // Struct\n\n\n      var fields = this.types[type];\n\n      if (fields) {\n        var encodedType = id(this._types[type]);\n        return function (value) {\n          var values = fields.map(function (_ref2) {\n            var name = _ref2.name,\n                type = _ref2.type;\n\n            var result = _this.getEncoder(type)(value[name]);\n\n            if (_this._types[type]) {\n              return keccak256(result);\n            }\n\n            return result;\n          });\n          values.unshift(encodedType);\n          return hexConcat(values);\n        };\n      }\n\n      return logger.throwArgumentError(\"unknown type: \".concat(type), \"type\", type);\n    }\n  }, {\n    key: \"encodeType\",\n    value: function encodeType(name) {\n      var result = this._types[name];\n\n      if (!result) {\n        logger.throwArgumentError(\"unknown type: \".concat(JSON.stringify(name)), \"name\", name);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"encodeData\",\n    value: function encodeData(type, value) {\n      return this.getEncoder(type)(value);\n    }\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, value) {\n      return keccak256(this.encodeData(name, value));\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(value) {\n      return this.encodeData(this.primaryType, value);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(value) {\n      return this.hashStruct(this.primaryType, value);\n    }\n  }, {\n    key: \"_visit\",\n    value: function _visit(type, value, callback) {\n      var _this2 = this;\n\n      // Basic encoder type (address, bool, uint256, etc)\n      {\n        var encoder = getBaseEncoder(type);\n\n        if (encoder) {\n          return callback(type, value);\n        }\n      } // Array\n\n      var match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n\n      if (match) {\n        var subtype = match[1];\n        var length = parseInt(match[3]);\n\n        if (length >= 0 && value.length !== length) {\n          logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n        }\n\n        return value.map(function (v) {\n          return _this2._visit(subtype, v, callback);\n        });\n      } // Struct\n\n\n      var fields = this.types[type];\n\n      if (fields) {\n        return fields.reduce(function (accum, _ref3) {\n          var name = _ref3.name,\n              type = _ref3.type;\n          accum[name] = _this2._visit(type, value[name], callback);\n          return accum;\n        }, {});\n      }\n\n      return logger.throwArgumentError(\"unknown type: \".concat(type), \"type\", type);\n    }\n  }, {\n    key: \"visit\",\n    value: function visit(value, callback) {\n      return this._visit(this.primaryType, value, callback);\n    }\n  }], [{\n    key: \"from\",\n    value: function from(types) {\n      return new TypedDataEncoder(types);\n    }\n  }, {\n    key: \"getPrimaryType\",\n    value: function getPrimaryType(types) {\n      return TypedDataEncoder.from(types).primaryType;\n    }\n  }, {\n    key: \"hashStruct\",\n    value: function hashStruct(name, types, value) {\n      return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n  }, {\n    key: \"hashDomain\",\n    value: function hashDomain(domain) {\n      var domainFields = [];\n\n      for (var name in domain) {\n        var type = domainFieldTypes[name];\n\n        if (!type) {\n          logger.throwArgumentError(\"invalid typed-data domain key: \".concat(JSON.stringify(name)), \"domain\", domain);\n        }\n\n        domainFields.push({\n          name: name,\n          type: type\n        });\n      }\n\n      domainFields.sort(function (a, b) {\n        return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n      });\n      return TypedDataEncoder.hashStruct(\"EIP712Domain\", {\n        EIP712Domain: domainFields\n      }, domain);\n    }\n  }, {\n    key: \"encode\",\n    value: function encode(domain, types, value) {\n      return hexConcat([\"0x1901\", TypedDataEncoder.hashDomain(domain), TypedDataEncoder.from(types).hash(value)]);\n    }\n  }, {\n    key: \"hash\",\n    value: function hash(domain, types, value) {\n      return keccak256(TypedDataEncoder.encode(domain, types, value));\n    } // Replaces all address types with ENS names with their looked up address\n\n  }, {\n    key: \"resolveNames\",\n    value: function resolveNames(domain, types, value, resolveName) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var ensCache, encoder, name;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                // Make a copy to isolate it from the object passed in\n                domain = shallowCopy(domain); // Look up all ENS names\n\n                ensCache = {}; // Do we need to look up the domain's verifyingContract?\n\n                if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                  ensCache[domain.verifyingContract] = \"0x\";\n                } // We are going to use the encoder to visit all the base values\n\n\n                encoder = TypedDataEncoder.from(types); // Get a list of all the addresses\n\n                encoder.visit(value, function (type, value) {\n                  if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                  }\n\n                  return value;\n                }); // Lookup each name\n\n                _context.t0 = _regeneratorRuntime.keys(ensCache);\n\n              case 6:\n                if ((_context.t1 = _context.t0()).done) {\n                  _context.next = 13;\n                  break;\n                }\n\n                name = _context.t1.value;\n                _context.next = 10;\n                return resolveName(name);\n\n              case 10:\n                ensCache[name] = _context.sent;\n                _context.next = 6;\n                break;\n\n              case 13:\n                // Replace the domain verifyingContract if needed\n                if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                  domain.verifyingContract = ensCache[domain.verifyingContract];\n                } // Replace all ENS names with their address\n\n\n                value = encoder.visit(value, function (type, value) {\n                  if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                  }\n\n                  return value;\n                });\n                return _context.abrupt(\"return\", {\n                  domain: domain,\n                  value: value\n                });\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }));\n    }\n  }, {\n    key: \"getPayload\",\n    value: function getPayload(domain, types, value) {\n      // Validate the domain fields\n      TypedDataEncoder.hashDomain(domain); // Derive the EIP712Domain Struct reference type\n\n      var domainValues = {};\n      var domainTypes = [];\n      domainFieldNames.forEach(function (name) {\n        var value = domain[name];\n\n        if (value == null) {\n          return;\n        }\n\n        domainValues[name] = domainChecks[name](value);\n        domainTypes.push({\n          name: name,\n          type: domainFieldTypes[name]\n        });\n      });\n      var encoder = TypedDataEncoder.from(types);\n      var typesWithDomain = shallowCopy(types);\n\n      if (typesWithDomain.EIP712Domain) {\n        logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n      } else {\n        typesWithDomain.EIP712Domain = domainTypes;\n      } // Validate the data structures and types\n\n\n      encoder.encode(value);\n      return {\n        types: typesWithDomain,\n        domain: domainValues,\n        primaryType: encoder.primaryType,\n        message: encoder.visit(value, function (type, value) {\n          // bytes\n          if (type.match(/^bytes(\\d*)/)) {\n            return hexlify(arrayify(value));\n          } // uint or int\n\n\n          if (type.match(/^u?int/)) {\n            return BigNumber.from(value).toString();\n          }\n\n          switch (type) {\n            case \"address\":\n              return value.toLowerCase();\n\n            case \"bool\":\n              return !!value;\n\n            case \"string\":\n              if (typeof value !== \"string\") {\n                logger.throwArgumentError(\"invalid string\", \"value\", value);\n              }\n\n              return value;\n          }\n\n          return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n        })\n      };\n    }\n  }]);\n\n  return TypedDataEncoder;\n}();","map":{"version":3,"sources":["/home/cynefin/Desktop/Angular Basics/blog/node_modules/@ethersproject/hash/lib.esm/typed-data.js"],"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","getAddress","BigNumber","arrayify","hexConcat","hexlify","hexZeroPad","isHexString","keccak256","deepCopy","defineReadOnly","shallowCopy","Logger","version","logger","id","padding","Uint8Array","fill","NegativeOne","from","Zero","One","MaxUint256","hexPadRight","bytes","padOffset","length","slice","hexTrue","toHexString","hexFalse","domainFieldTypes","name","chainId","verifyingContract","salt","domainFieldNames","checkString","key","throwArgumentError","JSON","stringify","domainChecks","toString","error","toLowerCase","Error","getBaseEncoder","type","match","signed","width","parseInt","String","boundsUpper","mask","boundsLower","add","mul","v","lt","gt","toTwos","encodeType","fields","map","join","TypedDataEncoder","types","Object","freeze","links","parents","subtypes","keys","forEach","uniqueNames","field","baseType","encoder","push","primaryTypes","filter","n","t","checkCircular","found","child","subtype","primaryType","st","sort","_types","_encoderCache","_getEncoder","subEncoder","getEncoder","encodedType","values","unshift","encodeData","hashStruct","callback","_visit","reduce","accum","domain","domainFields","a","b","indexOf","EIP712Domain","hashDomain","hash","encode","resolveName","ensCache","visit","domainValues","domainTypes","typesWithDomain","message"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { id } from \"./id\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return hexConcat([bytes, padding.slice(padOffset)]);\n    }\n    return hexlify(bytes);\n}\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return getAddress(value).toLowerCase();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return hexlify(bytes);\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                const v = BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return keccak256(value);\n        };\n        case \"string\": return function (value) {\n            return id(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\nexport class TypedDataEncoder {\n    constructor(types) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n        defineReadOnly(this, \"_encoderCache\", {});\n        defineReadOnly(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        }\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n                return keccak256(hexConcat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return keccak256(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return keccak256(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    static encode(domain, types, value) {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Make a copy to isolate it from the object passed in\n            domain = shallowCopy(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value) => {\n                if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for (const name in ensCache) {\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value) => {\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return { domain, value };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}