{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function get() {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) {\n    if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n  }\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {\n      ar.push(r.value);\n    }\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar rlp = __importStar(require(\"rlp\"));\n\nvar secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\n\nvar ethjs_util_1 = require(\"ethjs-util\");\n\nvar constants_1 = require(\"./constants\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar hash_1 = require(\"./hash\");\n\nvar helpers_1 = require(\"./helpers\");\n\nvar types_1 = require(\"./types\");\n\nvar Account = function () {\n  /**\n   * This constructor assigns and validates the values.\n   * Use the static factory methods to assist in creating an Account from varying data types.\n   */\n  function Account(nonce, balance, stateRoot, codeHash) {\n    if (nonce === void 0) {\n      nonce = new bn_js_1.default(0);\n    }\n\n    if (balance === void 0) {\n      balance = new bn_js_1.default(0);\n    }\n\n    if (stateRoot === void 0) {\n      stateRoot = constants_1.KECCAK256_RLP;\n    }\n\n    if (codeHash === void 0) {\n      codeHash = constants_1.KECCAK256_NULL;\n    }\n\n    this.nonce = nonce;\n    this.balance = balance;\n    this.stateRoot = stateRoot;\n    this.codeHash = codeHash;\n\n    this._validate();\n  }\n\n  Account.fromAccountData = function (accountData) {\n    var nonce = accountData.nonce,\n        balance = accountData.balance,\n        stateRoot = accountData.stateRoot,\n        codeHash = accountData.codeHash;\n    return new Account(nonce ? new bn_js_1.default(bytes_1.toBuffer(nonce)) : undefined, balance ? new bn_js_1.default(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);\n  };\n\n  Account.fromRlpSerializedAccount = function (serialized) {\n    var values = rlp.decode(serialized);\n\n    if (!Array.isArray(values)) {\n      throw new Error('Invalid serialized account input. Must be array');\n    }\n\n    return this.fromValuesArray(values);\n  };\n\n  Account.fromValuesArray = function (values) {\n    var _a = __read(values, 4),\n        nonce = _a[0],\n        balance = _a[1],\n        stateRoot = _a[2],\n        codeHash = _a[3];\n\n    return new Account(new bn_js_1.default(nonce), new bn_js_1.default(balance), stateRoot, codeHash);\n  };\n\n  Account.prototype._validate = function () {\n    if (this.nonce.lt(new bn_js_1.default(0))) {\n      throw new Error('nonce must be greater than zero');\n    }\n\n    if (this.balance.lt(new bn_js_1.default(0))) {\n      throw new Error('balance must be greater than zero');\n    }\n\n    if (this.stateRoot.length !== 32) {\n      throw new Error('stateRoot must have a length of 32');\n    }\n\n    if (this.codeHash.length !== 32) {\n      throw new Error('codeHash must have a length of 32');\n    }\n  };\n  /**\n   * Returns a Buffer Array of the raw Buffers for the account, in order.\n   */\n\n\n  Account.prototype.raw = function () {\n    return [types_1.bnToUnpaddedBuffer(this.nonce), types_1.bnToUnpaddedBuffer(this.balance), this.stateRoot, this.codeHash];\n  };\n  /**\n   * Returns the RLP serialization of the account as a `Buffer`.\n   */\n\n\n  Account.prototype.serialize = function () {\n    return rlp.encode(this.raw());\n  };\n  /**\n   * Returns a `Boolean` determining if the account is a contract.\n   */\n\n\n  Account.prototype.isContract = function () {\n    return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n  /**\n   * Returns a `Boolean` determining if the account is empty complying to the definition of\n   * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n   * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n   */\n\n\n  Account.prototype.isEmpty = function () {\n    return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n  };\n\n  return Account;\n}();\n\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\nexports.isValidAddress = function (hexAddress) {\n  try {\n    helpers_1.assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\n\n\nexports.toChecksumAddress = function (hexAddress, eip1191ChainId) {\n  helpers_1.assertIsHexString(hexAddress);\n  var address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();\n  var prefix = '';\n\n  if (eip1191ChainId) {\n    var chainId = types_1.toType(eip1191ChainId, types_1.TypeOutput.BN);\n    prefix = chainId.toString() + '0x';\n  }\n\n  var hash = hash_1.keccakFromString(prefix + address).toString('hex');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\n\n\nexports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n  return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\n\nexports.generateAddress = function (from, nonce) {\n  helpers_1.assertIsBuffer(from);\n  helpers_1.assertIsBuffer(nonce);\n  var nonceBN = new bn_js_1.default(nonce);\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\n\nexports.generateAddress2 = function (from, salt, initCode) {\n  helpers_1.assertIsBuffer(from);\n  helpers_1.assertIsBuffer(salt);\n  helpers_1.assertIsBuffer(initCode);\n  assert_1.default(from.length === 20);\n  assert_1.default(salt.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));\n  return address.slice(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\n\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1_1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  helpers_1.assertIsBuffer(publicKey);\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1_1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return secp256k1_1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  helpers_1.assertIsBuffer(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = Buffer.from(secp256k1_1.publicKeyConvert(pubKey, false).slice(1));\n  }\n\n  assert_1.default(pubKey.length === 64); // Only take the lower 160bits of the hash\n\n  return hash_1.keccak(pubKey).slice(-20);\n};\n\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nexports.privateToPublic = function (privateKey) {\n  helpers_1.assertIsBuffer(privateKey); // skip the type flag and use the X, Y points\n\n  return Buffer.from(secp256k1_1.publicKeyCreate(privateKey, false)).slice(1);\n};\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\n\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Converts a public key to the Ethereum format.\n */\n\n\nexports.importPublic = function (publicKey) {\n  helpers_1.assertIsBuffer(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = Buffer.from(secp256k1_1.publicKeyConvert(publicKey, false).slice(1));\n  }\n\n  return publicKey;\n};\n/**\n * Returns the zero address.\n */\n\n\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\n\n\nexports.isZeroAddress = function (hexAddress) {\n  try {\n    helpers_1.assertIsString(hexAddress);\n  } catch (e) {\n    return false;\n  }\n\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === hexAddress;\n};","map":{"version":3,"sources":["/home/cynefin/Desktop/Angular Basics/blog/node_modules/ethereumjs-util/dist.browser/account.js"],"names":["__createBinding","Object","create","o","m","k","k2","undefined","defineProperty","enumerable","get","__setModuleDefault","v","value","__importStar","mod","__esModule","result","hasOwnProperty","call","__read","n","Symbol","iterator","i","r","ar","e","next","done","push","error","__importDefault","exports","isZeroAddress","zeroAddress","importPublic","privateToAddress","privateToPublic","publicToAddress","pubToAddress","isValidPublic","isValidPrivate","generateAddress2","generateAddress","isValidChecksumAddress","toChecksumAddress","isValidAddress","Account","assert_1","require","bn_js_1","rlp","secp256k1_1","ethjs_util_1","constants_1","bytes_1","hash_1","helpers_1","types_1","nonce","balance","stateRoot","codeHash","default","KECCAK256_RLP","KECCAK256_NULL","_validate","fromAccountData","accountData","toBuffer","fromRlpSerializedAccount","serialized","values","decode","Array","isArray","Error","fromValuesArray","_a","prototype","lt","length","raw","bnToUnpaddedBuffer","serialize","encode","isContract","equals","isEmpty","isZero","hexAddress","assertIsString","test","eip1191ChainId","assertIsHexString","address","stripHexPrefix","toLowerCase","prefix","chainId","toType","TypeOutput","BN","toString","hash","keccakFromString","ret","parseInt","toUpperCase","from","assertIsBuffer","nonceBN","rlphash","slice","Buffer","toArray","salt","initCode","keccak256","concat","privateKey","privateKeyVerify","publicKey","sanitize","publicKeyVerify","pubKey","publicKeyConvert","keccak","publicKeyCreate","addressLength","addr","zeros","bufferToHex","zeroAddr"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isZeroAddress = exports.zeroAddress = exports.importPublic = exports.privateToAddress = exports.privateToPublic = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isValidAddress = exports.Account = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar rlp = __importStar(require(\"rlp\"));\nvar secp256k1_1 = require(\"ethereum-cryptography/secp256k1\");\nvar ethjs_util_1 = require(\"ethjs-util\");\nvar constants_1 = require(\"./constants\");\nvar bytes_1 = require(\"./bytes\");\nvar hash_1 = require(\"./hash\");\nvar helpers_1 = require(\"./helpers\");\nvar types_1 = require(\"./types\");\nvar Account = /** @class */ (function () {\n    /**\n     * This constructor assigns and validates the values.\n     * Use the static factory methods to assist in creating an Account from varying data types.\n     */\n    function Account(nonce, balance, stateRoot, codeHash) {\n        if (nonce === void 0) { nonce = new bn_js_1.default(0); }\n        if (balance === void 0) { balance = new bn_js_1.default(0); }\n        if (stateRoot === void 0) { stateRoot = constants_1.KECCAK256_RLP; }\n        if (codeHash === void 0) { codeHash = constants_1.KECCAK256_NULL; }\n        this.nonce = nonce;\n        this.balance = balance;\n        this.stateRoot = stateRoot;\n        this.codeHash = codeHash;\n        this._validate();\n    }\n    Account.fromAccountData = function (accountData) {\n        var nonce = accountData.nonce, balance = accountData.balance, stateRoot = accountData.stateRoot, codeHash = accountData.codeHash;\n        return new Account(nonce ? new bn_js_1.default(bytes_1.toBuffer(nonce)) : undefined, balance ? new bn_js_1.default(bytes_1.toBuffer(balance)) : undefined, stateRoot ? bytes_1.toBuffer(stateRoot) : undefined, codeHash ? bytes_1.toBuffer(codeHash) : undefined);\n    };\n    Account.fromRlpSerializedAccount = function (serialized) {\n        var values = rlp.decode(serialized);\n        if (!Array.isArray(values)) {\n            throw new Error('Invalid serialized account input. Must be array');\n        }\n        return this.fromValuesArray(values);\n    };\n    Account.fromValuesArray = function (values) {\n        var _a = __read(values, 4), nonce = _a[0], balance = _a[1], stateRoot = _a[2], codeHash = _a[3];\n        return new Account(new bn_js_1.default(nonce), new bn_js_1.default(balance), stateRoot, codeHash);\n    };\n    Account.prototype._validate = function () {\n        if (this.nonce.lt(new bn_js_1.default(0))) {\n            throw new Error('nonce must be greater than zero');\n        }\n        if (this.balance.lt(new bn_js_1.default(0))) {\n            throw new Error('balance must be greater than zero');\n        }\n        if (this.stateRoot.length !== 32) {\n            throw new Error('stateRoot must have a length of 32');\n        }\n        if (this.codeHash.length !== 32) {\n            throw new Error('codeHash must have a length of 32');\n        }\n    };\n    /**\n     * Returns a Buffer Array of the raw Buffers for the account, in order.\n     */\n    Account.prototype.raw = function () {\n        return [\n            types_1.bnToUnpaddedBuffer(this.nonce),\n            types_1.bnToUnpaddedBuffer(this.balance),\n            this.stateRoot,\n            this.codeHash,\n        ];\n    };\n    /**\n     * Returns the RLP serialization of the account as a `Buffer`.\n     */\n    Account.prototype.serialize = function () {\n        return rlp.encode(this.raw());\n    };\n    /**\n     * Returns a `Boolean` determining if the account is a contract.\n     */\n    Account.prototype.isContract = function () {\n        return !this.codeHash.equals(constants_1.KECCAK256_NULL);\n    };\n    /**\n     * Returns a `Boolean` determining if the account is empty complying to the definition of\n     * account emptiness in [EIP-161](https://eips.ethereum.org/EIPS/eip-161):\n     * \"An account is considered empty when it has no code and zero nonce and zero balance.\"\n     */\n    Account.prototype.isEmpty = function () {\n        return this.balance.isZero() && this.nonce.isZero() && this.codeHash.equals(constants_1.KECCAK256_NULL);\n    };\n    return Account;\n}());\nexports.Account = Account;\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\nexports.isValidAddress = function (hexAddress) {\n    try {\n        helpers_1.assertIsString(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    return /^0x[0-9a-fA-F]{40}$/.test(hexAddress);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details see [EIP-1191](https://eips.ethereum.org/EIPS/eip-1191).\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\nexports.toChecksumAddress = function (hexAddress, eip1191ChainId) {\n    helpers_1.assertIsHexString(hexAddress);\n    var address = ethjs_util_1.stripHexPrefix(hexAddress).toLowerCase();\n    var prefix = '';\n    if (eip1191ChainId) {\n        var chainId = types_1.toType(eip1191ChainId, types_1.TypeOutput.BN);\n        prefix = chainId.toString() + '0x';\n    }\n    var hash = hash_1.keccakFromString(prefix + address).toString('hex');\n    var ret = '0x';\n    for (var i = 0; i < address.length; i++) {\n        if (parseInt(hash[i], 16) >= 8) {\n            ret += address[i].toUpperCase();\n        }\n        else {\n            ret += address[i];\n        }\n    }\n    return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\nexports.isValidChecksumAddress = function (hexAddress, eip1191ChainId) {\n    return exports.isValidAddress(hexAddress) && exports.toChecksumAddress(hexAddress, eip1191ChainId) === hexAddress;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\nexports.generateAddress = function (from, nonce) {\n    helpers_1.assertIsBuffer(from);\n    helpers_1.assertIsBuffer(nonce);\n    var nonceBN = new bn_js_1.default(nonce);\n    if (nonceBN.isZero()) {\n        // in RLP we want to encode null in the case of zero nonce\n        // read the RLP documentation for an answer if you dare\n        return hash_1.rlphash([from, null]).slice(-20);\n    }\n    // Only take the lower 160bits of the hash\n    return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\nexports.generateAddress2 = function (from, salt, initCode) {\n    helpers_1.assertIsBuffer(from);\n    helpers_1.assertIsBuffer(salt);\n    helpers_1.assertIsBuffer(initCode);\n    assert_1.default(from.length === 20);\n    assert_1.default(salt.length === 32);\n    var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), from, salt, hash_1.keccak256(initCode)]));\n    return address.slice(-20);\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\nexports.isValidPrivate = function (privateKey) {\n    return secp256k1_1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.isValidPublic = function (publicKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    helpers_1.assertIsBuffer(publicKey);\n    if (publicKey.length === 64) {\n        // Convert to SEC1 for secp256k1\n        return secp256k1_1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n    }\n    if (!sanitize) {\n        return false;\n    }\n    return secp256k1_1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\nexports.pubToAddress = function (pubKey, sanitize) {\n    if (sanitize === void 0) { sanitize = false; }\n    helpers_1.assertIsBuffer(pubKey);\n    if (sanitize && pubKey.length !== 64) {\n        pubKey = Buffer.from(secp256k1_1.publicKeyConvert(pubKey, false).slice(1));\n    }\n    assert_1.default(pubKey.length === 64);\n    // Only take the lower 160bits of the hash\n    return hash_1.keccak(pubKey).slice(-20);\n};\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToPublic = function (privateKey) {\n    helpers_1.assertIsBuffer(privateKey);\n    // skip the type flag and use the X, Y points\n    return Buffer.from(secp256k1_1.publicKeyCreate(privateKey, false)).slice(1);\n};\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\nexports.privateToAddress = function (privateKey) {\n    return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Converts a public key to the Ethereum format.\n */\nexports.importPublic = function (publicKey) {\n    helpers_1.assertIsBuffer(publicKey);\n    if (publicKey.length !== 64) {\n        publicKey = Buffer.from(secp256k1_1.publicKeyConvert(publicKey, false).slice(1));\n    }\n    return publicKey;\n};\n/**\n * Returns the zero address.\n */\nexports.zeroAddress = function () {\n    var addressLength = 20;\n    var addr = bytes_1.zeros(addressLength);\n    return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if a given address is the zero address.\n */\nexports.isZeroAddress = function (hexAddress) {\n    try {\n        helpers_1.assertIsString(hexAddress);\n    }\n    catch (e) {\n        return false;\n    }\n    var zeroAddr = exports.zeroAddress();\n    return zeroAddr === hexAddress;\n};\n"]},"metadata":{},"sourceType":"script"}