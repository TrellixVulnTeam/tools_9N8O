{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Address = void 0;\n\nvar assert_1 = __importDefault(require(\"assert\"));\n\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\n\nvar bytes_1 = require(\"./bytes\");\n\nvar account_1 = require(\"./account\");\n\nvar Address = function () {\n  function Address(buf) {\n    assert_1.default(buf.length === 20, 'Invalid address length');\n    this.buf = buf;\n  }\n  /**\n   * Returns the zero address.\n   */\n\n\n  Address.zero = function () {\n    return new Address(bytes_1.zeros(20));\n  };\n  /**\n   * Returns an Address object from a hex-encoded string.\n   * @param str - Hex-encoded address\n   */\n\n\n  Address.fromString = function (str) {\n    assert_1.default(account_1.isValidAddress(str), 'Invalid address');\n    return new Address(bytes_1.toBuffer(str));\n  };\n  /**\n   * Returns an address for a given public key.\n   * @param pubKey The two points of an uncompressed key\n   */\n\n\n  Address.fromPublicKey = function (pubKey) {\n    assert_1.default(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n    var buf = account_1.pubToAddress(pubKey);\n    return new Address(buf);\n  };\n  /**\n   * Returns an address for a given private key.\n   * @param privateKey A private key must be 256 bits wide\n   */\n\n\n  Address.fromPrivateKey = function (privateKey) {\n    assert_1.default(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n    var buf = account_1.privateToAddress(privateKey);\n    return new Address(buf);\n  };\n  /**\n   * Generates an address for a newly created contract.\n   * @param from The address which is creating this new address\n   * @param nonce The nonce of the from account\n   */\n\n\n  Address.generate = function (from, nonce) {\n    assert_1.default(bn_js_1.default.isBN(nonce));\n    return new Address(account_1.generateAddress(from.buf, nonce.toArrayLike(Buffer)));\n  };\n  /**\n   * Generates an address for a contract created using CREATE2.\n   * @param from The address which is creating this new address\n   * @param salt A salt\n   * @param initCode The init code of the contract being created\n   */\n\n\n  Address.generate2 = function (from, salt, initCode) {\n    assert_1.default(Buffer.isBuffer(salt));\n    assert_1.default(Buffer.isBuffer(initCode));\n    return new Address(account_1.generateAddress2(from.buf, salt, initCode));\n  };\n  /**\n   * Is address equal to another.\n   */\n\n\n  Address.prototype.equals = function (address) {\n    return this.buf.equals(address.buf);\n  };\n  /**\n   * Is address zero.\n   */\n\n\n  Address.prototype.isZero = function () {\n    return this.equals(Address.zero());\n  };\n  /**\n   * True if address is in the address range defined\n   * by EIP-1352\n   */\n\n\n  Address.prototype.isPrecompileOrSystemAddress = function () {\n    var addressBN = new bn_js_1.default(this.buf);\n    var rangeMin = new bn_js_1.default(0);\n    var rangeMax = new bn_js_1.default('ffff', 'hex');\n    return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n  };\n  /**\n   * Returns hex encoding of address.\n   */\n\n\n  Address.prototype.toString = function () {\n    return '0x' + this.buf.toString('hex');\n  };\n  /**\n   * Returns Buffer representation of address.\n   */\n\n\n  Address.prototype.toBuffer = function () {\n    return Buffer.from(this.buf);\n  };\n\n  return Address;\n}();\n\nexports.Address = Address;","map":{"version":3,"sources":["/home/cynefin/Desktop/Angular Basics/blog/node_modules/ethereumjs-util/dist.browser/address.js"],"names":["__importDefault","mod","__esModule","Object","defineProperty","exports","value","Address","assert_1","require","bn_js_1","bytes_1","account_1","buf","default","length","zero","zeros","fromString","str","isValidAddress","toBuffer","fromPublicKey","pubKey","Buffer","isBuffer","pubToAddress","fromPrivateKey","privateKey","privateToAddress","generate","from","nonce","isBN","generateAddress","toArrayLike","generate2","salt","initCode","generateAddress2","prototype","equals","address","isZero","isPrecompileOrSystemAddress","addressBN","rangeMin","rangeMax","gte","lte","toString"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Address = void 0;\nvar assert_1 = __importDefault(require(\"assert\"));\nvar bn_js_1 = __importDefault(require(\"bn.js\"));\nvar bytes_1 = require(\"./bytes\");\nvar account_1 = require(\"./account\");\nvar Address = /** @class */ (function () {\n    function Address(buf) {\n        assert_1.default(buf.length === 20, 'Invalid address length');\n        this.buf = buf;\n    }\n    /**\n     * Returns the zero address.\n     */\n    Address.zero = function () {\n        return new Address(bytes_1.zeros(20));\n    };\n    /**\n     * Returns an Address object from a hex-encoded string.\n     * @param str - Hex-encoded address\n     */\n    Address.fromString = function (str) {\n        assert_1.default(account_1.isValidAddress(str), 'Invalid address');\n        return new Address(bytes_1.toBuffer(str));\n    };\n    /**\n     * Returns an address for a given public key.\n     * @param pubKey The two points of an uncompressed key\n     */\n    Address.fromPublicKey = function (pubKey) {\n        assert_1.default(Buffer.isBuffer(pubKey), 'Public key should be Buffer');\n        var buf = account_1.pubToAddress(pubKey);\n        return new Address(buf);\n    };\n    /**\n     * Returns an address for a given private key.\n     * @param privateKey A private key must be 256 bits wide\n     */\n    Address.fromPrivateKey = function (privateKey) {\n        assert_1.default(Buffer.isBuffer(privateKey), 'Private key should be Buffer');\n        var buf = account_1.privateToAddress(privateKey);\n        return new Address(buf);\n    };\n    /**\n     * Generates an address for a newly created contract.\n     * @param from The address which is creating this new address\n     * @param nonce The nonce of the from account\n     */\n    Address.generate = function (from, nonce) {\n        assert_1.default(bn_js_1.default.isBN(nonce));\n        return new Address(account_1.generateAddress(from.buf, nonce.toArrayLike(Buffer)));\n    };\n    /**\n     * Generates an address for a contract created using CREATE2.\n     * @param from The address which is creating this new address\n     * @param salt A salt\n     * @param initCode The init code of the contract being created\n     */\n    Address.generate2 = function (from, salt, initCode) {\n        assert_1.default(Buffer.isBuffer(salt));\n        assert_1.default(Buffer.isBuffer(initCode));\n        return new Address(account_1.generateAddress2(from.buf, salt, initCode));\n    };\n    /**\n     * Is address equal to another.\n     */\n    Address.prototype.equals = function (address) {\n        return this.buf.equals(address.buf);\n    };\n    /**\n     * Is address zero.\n     */\n    Address.prototype.isZero = function () {\n        return this.equals(Address.zero());\n    };\n    /**\n     * True if address is in the address range defined\n     * by EIP-1352\n     */\n    Address.prototype.isPrecompileOrSystemAddress = function () {\n        var addressBN = new bn_js_1.default(this.buf);\n        var rangeMin = new bn_js_1.default(0);\n        var rangeMax = new bn_js_1.default('ffff', 'hex');\n        return addressBN.gte(rangeMin) && addressBN.lte(rangeMax);\n    };\n    /**\n     * Returns hex encoding of address.\n     */\n    Address.prototype.toString = function () {\n        return '0x' + this.buf.toString('hex');\n    };\n    /**\n     * Returns Buffer representation of address.\n     */\n    Address.prototype.toBuffer = function () {\n        return Buffer.from(this.buf);\n    };\n    return Address;\n}());\nexports.Address = Address;\n"]},"metadata":{},"sourceType":"script"}